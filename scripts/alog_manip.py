#!/usr/bin/python
"""
collection of functions for manipulating *.alogs

importing - use <import alog_manip>, these functions have interdependencies

Author: Robert Cofield
Created 6/6/2012
Python v2.7.3, using Ubuntu Precise (12.04)
"""

#############################################################################################


def pullByStr2new(alogSrc, alogTgt, desStr):
    """
    finds msgs with a string in meas type or source and creates a separate *.alog file from those msgs

    INPUTS:
        alogSrc     ::  ABSOLUTE PATH STRING of source *.alog file
        alogTgt     ::  ABSOLUTE PATH STRING of desired target *.alog file
        desStr      ::  messages containing any STRING in this LIST will be copied

    -will overwrite alogTgt if already existing

    """
    import csv, os

    curdir = os.getcwd()
    os.chdir('/') # go to root so that reader can use abs pathname
    src = open(alogSrc, 'rU') # read source alogs
    tgt = open(alogTgt, 'w')
    os.chdir(curdir)
    
    tgt.write('%% Generated by alog_manip.pullByStr2new\n')

    for desired in range(len(desStr)):
        desStr[desired] = ' ' + desStr[desired] + ' '
        #this keeps things like 'zLat' and 'zLatStdDev' from causing redundancies`
    
    for line in extractData(src, desStr):
        tgt.write(line + '\n')

    src.close()
    tgt.close()


def extractData(src, desStr):
    """
    yields msgs in list format which contain a desired string in the source (third) column

        -slave function to pullByStr2new

    src         ::  reader object from source *.alog file
    desStr      ::  string we're looking for
    """

    for line in src:
        line = str(line) # now each line is a string
        line = line.rstrip()
        if '%%' in line: #header
            yield line

        for desired in desStr:
            if desired in line:
                yield line


##################################################################################
### rename desired measurements ###
##################################################################################

def replStr(alogSrc, alogDst, tgtStrs, desStrs):
    """
    in the *.alog source file at absolute path alogSrc, finds strings in list tgtStrs in either 2nd or 3rd columns and replaces them with corresponding string in list desStrs, then saves changes to *.alog destination file at absolute path alogDst

    -no changes made to the source file

    Note that output is not yet in pretty justified columns

    This needs to have more file I/O stuff - delete old file & write new?

    not working - consider using extractData and making it more robust

    """
    import os

    curdir = os.getcwd()
    os.chdir('/')
    src = open(alogSrc, 'rU')
    dst = open(alogDst, 'w')
    os.chdir(curdir)

    dst.write('%% This file has been modified by alog_manip.replStr \n')

    for phrase in tgtStrs: # take care of possible name confusions (find too many targets)
        phrase = ' ' + phrase + ' '
    for phrase in desStrs:
        phrase = ' ' + phrase + ' '


    for msg in src:
        if '%%' in msg: #will be written with dblspc at the end of this for loop unless we take of the \n now
            msg = msg[0:-2]
        for ind in range(len(tgtStrs)): # use indices of inputs in case of lists
            if tgtStrs[ind] in msg: # bingo.
                msg == msg.split(msg)
                if msg[1] == tgtStrs[ind]: # its the measurement we're replacing
                    msg[1] = desStrs[ind]
                elif msg[2] == tgtStrs[ind]: # its the sensor we're replacing
                    msg[2] == desStrs[ind]
                else:
                    print('Warning:: Bad target string')
                msg = reconstructLine(msg)
        dst.write(msg + '\n') # took \n off the non-reconstituted msgs (comments)

    src.close()
    dst.close()


###########################################################################################
### Reconstruct alog file with pretty formatting (justified) ###
###########################################################################################

def reconstructLine(msgList):
    """
    INPUT msgList is a python list of length 4:
        time (string), zMeasurment (string), gSensor (string), value (string)

    OUTPUT will be a one-line string with no formatting characters

    typical (short enough variable names) spacing:
    |[col1]         |[col17]        |[col38]        |[col54]
    time(16cols)    meas(21cols)    sens(16cols)    valu(inf_cols)

    If one measurment is too long, the following parts are bumped back, even if they could have been inline correctly... fix this
    """
    timeSpc = 16 # size allotted each of 4 columns
    measSpc = 21
    sensSpc = 16

    time_short_enough = True
    meas_short_enough = True
    sens_short_enough = True

    time = msgList[0] #keep as string
    meas = msgList[1] 
    sens = msgList[2]
    valu = msgList[3] #keep as string

    if len(time) >= timeSpc:
        time_short_enough = False
    if len(meas) >= measSpc:
        meas_short_enough = False
    if len(sens) >= sensSpc:
        sens_short_enough

    line = time
    if time_short_enough:
        line += (' '*(timeSpc-len(time)) + meas)
    else:
        line += (' ' + meas)

    if meas_short_enough:
        line += (' '*(measSpc-len(meas)) + sens)
    else:
        line += (' ' + sens)

    if sens_short_enough:
        line += (' '*(sensSpc-len(sens)) + valu)
    else:
        line += (' ' + valu)

    return line


###########################################################################################
### Value Changing Functions ###
###########################################################################################

def makeNoisy(alogSrc, alogTgt, meas, mag):
    """
    Adds gaussian white noise to specific measurements in an *.alog file.

    INPUTS:
        alog        ::  ABSOLUTE PATH of *.alog file
        meas        ::  LIST of WHICH MEASUREMENT (z_______) to corrupt with gaussian noise
        mag         ::  LIST of std devs, corresponding to meas

    Note that output is not yet in pretty justified columns --> examine Create_alog.m to fix
    """
    import os
    from numpy.random import normal

    # if meas[0] != 'z':
    #     error()

    curdir = os.getcwd()
    os.chdir('/')
    src = open(alogSrc, 'rU')
    tgt = open(alogTgt, 'w')
    os.chdir(curdir)

    for msg in src:
        if ("%%" in msg):
            msg = msg[0:-2] # get rid of \n at end for printing later
        else:
            msg = msg.split()
            for des in range(len(meas)):
                if msg[1] == meas[des]:
                    noise = normal(float(msg[3]), mag[des], 1)
                    msg[3] = str(noise[0]) # center deviation about measurement
            msg = reconstructLine(msg)
        # print(msg)

        tgt.write(msg + '\n')


########################################################################################
### Tools for I/O using python datatypes ###
########################################################################################

def alogrd_dict(alogfile):
    """
    Prouces a dictionary dctn of info given the absolute path of an *.alog file

    Dictionary Structure:
        dctn['header']: list of each line containing '%%'
        dctn['gSensor']['zMeasurment'][Time] = value

    Presently assumes that 4th column (value) is convertible to float
        -need to make it dance with lidar strings

    Note that no newline '\n' is present in data when using later.

    """
    import os

    # curdir = os.getcwd()
    # os.chdir('/')
    alog = open(alogfile, 'rU')
    # os.chdir(curdir)

    dctn = dict()
    dctn['header'] = ['%% This dictionary created by alog_manip.alogrd_dict']
    for msg in alog: # broken by lines, are now strings
        msg = msg[0:-1] # remove \n at the end of the string
        if '%%' in msg:
            dctn['header'].append(msg) # assume all comments occur at beginning of file
        else:
            msg = msg.split()
            if msg[2] not in dctn: # none from this gSource yet
                dctn[msg[2]] = {}
            if msg[1] not in dctn[msg[2]]: # none in this gSource from this zMeas yet
                dctn[msg[2]][msg[1]] = {}
            dctn[msg[2]][msg[1]][float(msg[0])] = float(msg[3])

    return(dctn)

###############################################################################


def increaseFreq(loHz, desHz):
    """
    Given a dictionary of alog data, increases message frequency to scpecified rate via interpolation
    ***It is assumed loHz will have the same format as output by the function alogrd_dict***
    ***Assume all msgs occur in chronological order***

    linearly adds data between supplied datapoints - no recalculating given data
        -note this function created to have smoother visualizations from alog data, not to be used in any mathematical calculations
    yields time to 5 decimal places
    """
    from scipy.interpolate import interp1d
    import time
    from pprint import pprint
    from numpy import linspace, floor
    # import logging

    if desHz > 100000:
        raise ValueError('Max Frequency is 100,000 (5 decimal places)')
    now = time.asctime(time.localtime(time.time()))    
    stamp = ''.join(['%% The following was created by alog_manip.increaseFreq on ', now])
    increase_msg = ''.join(['%% Resultant Frequency: ',str(desHz),' Hz'])
    hiHz = {}
    hiHz['header'] = [stamp,increase_msg,'%%%%'] + loHz['header']

    global sens, meas, dat

    def main():
        """ Primary interpolation function for increaseFreq
        Consider using uniaxial spline --> would have one function for all of dictionary dat
        """
        orig_times = sorted(dat)
        for n in range(len(dat) - 1):
            linfun = interp1d([orig_times[n], orig_times[n+1]],
                              [dat[orig_times[n]], dat[orig_times[n+1]]])
            dt = orig_times[n+1] - orig_times[n] # current
            freq = 1/dt # current
            if dt < (1/desHz):
                print('found instance where Freq already at/above desired Freq')
            else:
                new_dt = dt*freq/desHz
                print('number of new time steps created: %f' % (dt/new_dt))
                new_times = linspace(orig_times[n],orig_times[n+1],floor(dt/new_dt))
                # print(new_times)
                new_values = linfun(new_times)
                print('\nnew_values')
                pprint(new_values)
                for m in range(len(new_values)):
                    newdat[new_times[m]] = new_values[m]

    # go thru and pull out dictionaries {time: value} then send to interpolation func
    for sens in loHz:
        if sens == 'header':
            pass
        else:
            hiHz[sens] = {}
            for meas in loHz[sens]:
                hiHz[sens][meas] = {}
                dat = loHz[sens][meas]
                if len(dat) == 1:
                    pass # only 1 data point
                else:
                    newdat = {}
                    main()

    return hiHz